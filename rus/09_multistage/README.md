# Многоэтапная сборка Docker-образов

- [Многоэтапная сборка Docker-образов](#многоэтапная-сборка-docker-образов)
  - [Проблема эффективности контейнеров](#проблема-эффективности-контейнеров)
  - [Устаревший подход к процессам сборки](#устаревший-подход-к-процессам-сборки)
    - [Пример](#пример)
  - [Основные принципы многоэтапной сборки](#основные-принципы-многоэтапной-сборки)
    - [Пример многоэтапной сборки](#пример-многоэтапной-сборки)
  - [Общий вид многоэтапной сборки](#общий-вид-многоэтапной-сборки)
  - [Библиография](#библиография)

## Проблема эффективности контейнеров

Часто при создании Docker-образов возникает проблема эффективности: образы становятся слишком большими, что замедляет их загрузку и увеличивает потребление ресурсов. Это связано с тем, что в образ включаются все необходимые для работы приложения файлы, включая те, которые не используются во время работы приложения. Например, в образ могут попасть исходные коды, тесты, документация и т.д. Размеры образа могут достигать нескольких гигабайт.

Чтобы создать действительно эффективный, маленький и безопасный образ, рекомендуется выполнять процесс сборки в несколько этапов. Каждый этап сборки выполняется в отдельном контейнере и результат его работы сохраняется в образе. В итоге, вместо одного большого образа, создаётся несколько промежуточных, хранящих результаты работы каждого этапа. В финальном образе будут только те файлы, которые необходимы для работы приложения.

## Устаревший подход к процессам сборки

Процесс разработки программного продукта включает следующие шаги:

- Настройка окружения
- Написание кода
- Компиляция и сборка
- Тестирование
- Развертывание

Похожим образом происходит сборка Docker-образа:

- Настройка окружения
- Установка зависимостей
- Сборка приложения
- Тестирование
- Развертывание контейнера

Для каждого этапа сборки создавался отдельный контейнер, который выполнял свою задачу. Например, для установки зависимостей использовался контейнер с установленным компилятором и библиотеками, для сборки приложения - контейнер с установленным компилятором и библиотеками, для тестирования - контейнер с установленным тестовым фреймворком и т.д. В конце результаты работы каждого контейнера объединялись в один образ.

Соответственно, для каждого этапа создавался свой `Dockerfile`, который выполнял свою задачу, а также скрипт для объединения результатов работы контейнеров в один образ.

### Пример

Пусть у нас есть приложение CPP (файл `helloworld.cpp`), которое мы хотим запустить в контейнере.

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```

Для сборки образа создадим следующие файлы:

- `Dockerfile.build` - для сборки приложения
- `Dockerfile.run` - для запуска приложения
- `build.sh` - скрипт для сборки образа

`Dockefile.build`:

```Dockerfile
FROM gcc:latest AS build

WORKDIR /app

COPY helloworld.cpp .

RUN g++ helloworld.cpp -o helloworld -static
```

`Dockerfile.run`:

```Dockerfile
FROM debian:latest

WORKDIR /app

COPY app/helloworld .

CMD ["./helloworld"]
```

`build.sh`:

```bash
#!/bin/bash
echo "Building helloworld-build image..."
docker build -t helloworld-build -f Dockerfile.build .

echo "Extracting helloworld binary..."
mkdir -p app
docker create --name extract helloworld-build
docker cp extract:/app/helloworld app/helloworld
docker rm -f extract

echo "Building helloworld-run image..."
docker build -t helloworld-run -f Dockerfile.run .
rm -f app/helloworld
```

При запуске скрипта `build.sh`:

- создается образ `helloworld-build`, который собирает приложение;
- запускается контейнер `extract`, в котором собранное приложение копируется на хост-машину;
- удаляется контейнер `extract`;
- создается образ `helloworld-run`, который запускает приложение.

Использование многоэтапной сборки позволяет упростить процесс сборки образа и уменьшить его размер.

## Основные принципы многоэтапной сборки

Многоэтапная сборка позволяет создавать образы, которые содержат только необходимые для работы приложения файлы, используя только один Dockerfile. Для этого используются следующие принципы:

- Каждая инструкция использует некоторый базовый образ и задаёт этап сборки;
- Каждый этап сборки выполняется в отдельном контейнере;
- Результат работы каждого этапа сохраняется в образе;
- Можно копировать файлы из одного этапа в другой.

### Пример многоэтапной сборки

В этом случае наш пример можно упростить до одного `Dockerfile`:

```Dockerfile
FROM gcc:latest AS build

WORKDIR /app

COPY helloworld.cpp .

RUN g++ helloworld.cpp -o helloworld -static

FROM debian:latest

WORKDIR /app

COPY --from=0 app/helloworld .

CMD ["./helloworld"]
```

Сборка образа в этом случае сокращается до одной команды:

```bash
docker build -t helloworld-run .
```

Это возможно благодаря тому что инструкция `COPY` может копировать файлы из одного этапа в другой, при этом необходимо указать номер этапа, из которого нужно скопировать файлы.

Кроме того, можно этапам сборки задавать имена, чтобы обращаться к ним по имени:

```Dockerfile
FROM gcc:latest AS build

WORKDIR /app

COPY helloworld.cpp .

RUN g++ helloworld.cpp -o helloworld

FROM debian:latest AS run

WORKDIR /app

COPY --from=build app/helloworld .

CMD ["./helloworld"]
```

## Общий вид многоэтапной сборки

Естественно, многоэтапная сборка позволяет не только собирать приложения, но и выполнять другие задачи: тестирование, анализ кода, сборку документации и т.д.

В общем виде многоэтапная сборка может выглядеть следующим образом:

```Dockerfile
# создание базового образа
FROM debian:latest AS base

# ...

# установка зависимостей
FROM base AS dependencies

# ...

# сборка приложения
FROM dependencies AS build

# ...

# тестирование приложения
FROM build AS test

# ...

# развертывание приложения
FROM debian

# копирование файлов из других этапов
COPY --from=build /app/app /app/app

# запуск приложения
CMD ["./app"]
```

## Библиография

1. [pxeno, Полное руководство по созданию Docker-образа для обслуживания системы машинного обучения в продакшене, habr.com](https://habr.com/ru/companies/vk/articles/548480/)
2. [BOOTLOADER, Многоэтапные (multi-stage builds) сборки в Docker, habr.com](https://habr.com/ru/articles/349802/)
3. [Использование многоэтапных (multi-stage) сборок в Docker, cloud.croc.ru](https://cloud.croc.ru/blog/about-technologies/multi-stage-v-docker/)
4. [Docker, Multi-stage builds, docs.docker.com](https://docs.docker.com/build/building/multi-stage/)
