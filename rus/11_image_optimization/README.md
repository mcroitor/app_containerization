# Оптимизация образа контейнера

- [Оптимизация образа контейнера](#оптимизация-образа-контейнера)
  - [Получение информации о размере образа](#получение-информации-о-размере-образа)
  - [Минимальный базовый образ](#минимальный-базовый-образ)
  - [Многоэтапная сборка](#многоэтапная-сборка)
  - [Удаление неиспользуемых зависимостей и временных файлов](#удаление-неиспользуемых-зависимостей-и-временных-файлов)
  - [Уменьшение количества слоев](#уменьшение-количества-слоев)
  - [Перепаковка образа](#перепаковка-образа)
  - [Использование .dockerignore](#использование-dockerignore)
  - [Хранение данных вне образа](#хранение-данных-вне-образа)
  - [Кеширование слоев образа](#кеширование-слоев-образа)
  - [Библиография](#библиография)

Простота определения образов контейнеров позволяет их быстро создавать и использовать, а это в свою очередь ведет к допущению ошибок и созданию избыточных образов. Обычным делом является создание образа размеров в несколько гигабайт, что явно является ошибкой. Скорее всего данный образ содержит в себе данные, которые могут быть вынесены во внешние тома или вообще не нужны; ненужные зависимости, которые могут быть удалены; временные файлы и кэш, которые могут быть очищены; и т.д.

Большой размер образа имеет следующие недостатки:

- долгое время загрузки образа из репозитория;
- занимает больше места на диске;
- занимают больше места в памяти.

То есть большой образ требует больше ресурсов для загрузки, хранения и запуска. Поэтому оптимизация образа контейнера является важным шагом в разработке и использовании контейнеров.

## Получение информации о размере образа

Чтобы просмотреть список образов, можно воспользоваться командой `docker images` (или `docker image ls`). Выполнение этой команды покажет список образов, включая их размеры. Например:

```shell
$ docker images
docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
lab07        latest    4e96acf7022c   5 days ago   468MB
<none>       <none>    3de1890f5bde   5 days ago   468MB
myphp        latest    ec1fdb037c54   8 days ago   162MB
```

Получение информации о слоях образа можно выполнить с помощью команды `docker history`. Например:

```shell
$ docker history myphp
IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT
ec1fdb037c54   8 days ago   CMD ["/app/php" "-v"]                           0B        buildkit.dockerfile.v0
<missing>      8 days ago   WORKDIR /app                                    0B        buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libicui18n.so…   3.31MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libicudata.so…   31.3MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libicuuc.so.7…   2.08MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libsqlite3.so…   1.44MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libgmp.so.10 …   529kB     buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libpspell.so.…   14kB      buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libmariadb.so…   337kB     buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libxml2.so.2 …   1.75MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /app/php/sapi/cli/php /app/php # buildk…   40.7MB    buildkit.dockerfile.v0
<missing>      9 days ago   /bin/sh -c #(nop)  CMD ["bash"]                 0B
<missing>      9 days ago   /bin/sh -c #(nop) ADD file:5d6b639e8b6bcc011…   80.6MB
```

## Минимальный базовый образ

Создание своего образа контейнера начинается с выбора базового образа. И чем меньше размер базового образа, тем меньше будет размер конечного образа. Например, можно использовать образ `alpine`, который имеет размер около 7 МБ, вместо `ubuntu`, который имеет размер около 80 МБ.

Также можно использовать образ `scratch`, который не содержит ничего, и добавить в него только необходимые файлы и зависимости. Однако, часто разработчикам при работе их приложения нужны некоторые свойства операционной системы, поэтому они останавливаются на образе `alpine` как на минимальном базовом образе.

Можно выбирать специализированные образы под конкретные задачи, которые часто предлагают оптимизированные версии. Например для Python можно использовать образ `python:alpine`, который содержит минимальный набор пакетов для работы с Python.

## Многоэтапная сборка

Многоэтапная сборка позволяет уменьшить размер образа контейнера, так как в конечном образе остаются только необходимые файлы и зависимости. Например, можно использовать образ с компилятором для сборки приложения, а затем скопировать только исполняемый файл в конечный образ.

## Удаление неиспользуемых зависимостей и временных файлов

Удаление неиспользуемых зависимостей позволяет уменьшить размер образа контейнера. Например, после установки пакетов можно удалить временные файлы и кэш, чтобы уменьшить размер образа.

Данная процедура имеет смысл в случае объединения слоёв образа или в случае перепаковки образа. В противном случае, удаление временных файлов и кэша не приведет к уменьшению размера образа.

## Уменьшение количества слоев

Образ хранит информацию о каждом слое, что увеличивает его размер. Кроме того, каждый слой образа представляется промежуточным образом, хранение которого требует дополнительного места на диске.

Объединение команд в один слой позволяет уменьшить количество промежуточных образов, а также уменьшить размер образа за счет уменьшения количества метаданных. Кроме того, невозможно создать образ меньшего размера если промежуточные образы имеют больший размер.

Вместо создания временного слоя для установки пакетов и удаления кэша, можно выполнить все команды в одном слое.

Например, образ, построенный на базе `Dockefile`:

```dockerfile
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y php-cli
```

будет иметь примерно тот же размер, что и образ, построенный на базе `Dockerfile`:

```dockerfile
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y php-cli
RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
```

Однако объединение команд в один слой позволяет уменьшить размер образа:

```dockerfile
FROM debian:bookworm-slim

RUN apt-get update && \
    apt-get install -y php-cli && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
```

## Перепаковка образа

Перепаковка образа позволяет слить все слои образа в один слой, что уменьшает размер образа. 

> Примечание: перепаковка образа приводит к потере преимущества совместного использования слоёв образа разными образами. Кроме того, теряются все метаданные образа, а также открываемые порты, переменные окружения и т.д. Использовать данный способ можно только если вы пытаетесь оптимизировать чужой образ.

Для перепаковки образа можно воспользоваться тем фактом, что при создании контейнера сливает все слои образа в один слой. Например, можно создать контейнер из образа и затем создать образ из контейнера.

Если образ называется `myphp`, то перепаковка образа будет выглядеть следующим образом:

```shell
# Создание контейнера из образа
$ docker create --name myphp myphp
# Создание образа из контейнера
$ docker export myphp | docker import - myphp:optimized
```

## Использование .dockerignore

Использование файла `.dockerignore` позволяет исключить из контекста сборки файлы и директории, которые не нужны для создания образа. Частой практикой является копирование всего контекста сборки, что ведет к включению в образ ненужных файлов и директорий. Поэтому рекомендуется использовать файл `.dockerignore` для исключения ненужных файлов и директорий.

Пример файла `.dockerignore`:

```dockerfile
# .dockerignore
.git
.vscode
__pycache__
*.pyc
```

## Хранение данных вне образа

Хранение данных вне образа позволяет уменьшить размер образа контейнера. Например, можно использовать внешние тома для хранения web приложения. Однако следует помнить, что внешние тома могут быть сетевыми дисками, что может увеличить время работы приложения за счет сетевой задержки.

## Кеширование слоев образа

Docker активно использует кеширование слоев образа, что позволяет ускорить сборку образа. Однако, кеширование слоев образа приводит к потребления дисковой памяти. Чтобы эффективно использовать кеширование необходимо учитывать порядок команд в `Dockerfile` и использовать многоэтапную сборку.

При изменении команды `RUN` все последующие команды будут пересобраны, что приведет к увеличению времени сборки образа. Поэтому необходимо сначала выполнять команды, которые меньше подвержены изменениям (например, настройка окружения), а затем выполнять команды, которые чаще изменяются (копирование приложения).

В указанном примере образ будет пересобираться полностью при каждом изменении приложения:

```dockerfile
FROM nginx

COPY . /usr/share/nginx/html
RUN apt-get update && apt-get install -y php-cli
```

Однако, если поменять местами команды `RUN` и `COPY`, то при изменении приложения образ будет пересобираться только частично, что ускорит сборку образа:

```dockerfile
FROM nginx

RUN apt-get update && apt-get install -y php-cli

COPY . /usr/share/nginx/html
```

## Библиография

1. [Predrag Rakić, Docker Image Size – Does It Matter?, semaphoreci.com, 2021-03-30](https://semaphoreci.com/blog/2018/03/14/docker-image-size.html)
2. [Rafael Benevides, Keep it small: a closer look at Docker image sizing, RedHat, 2016-03-09](https://developers.redhat.com/blog/2016/03/09/more-about-docker-images-size)
3. [Bibin Wilson, Shishir Khandelwal, How to Reduce Docker Image Size: 6 Optimization Methods, devopscube.com, 2023-08-22](https://devopscube.com/reduce-docker-image-size/)
4. [Jeff Hale, Slimming Down Your Docker Images, towardsdatascience.com, 2019-01-31](https://towardsdatascience.com/slimming-down-your-docker-images-275f0ca9337e)
